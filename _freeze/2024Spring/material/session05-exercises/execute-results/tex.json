{
  "hash": "f6615836d338bbf1485fea270d7c50e4",
  "result": {
    "markdown": "---\ntitle: \"Exercises for Recap Session 1\"\ndate: \"2024-04-18\"\ndate-modified: last-modified\nformat: \n    html: \n        highlight-style: github\n    pdf: \n        toc: false\n---\n\n\n\n# Exercise 1: Basic object types I\n\n1. Create a vector containing the numbers `2`, `5`, `2.4` and `11`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_vec <- c(2, 5, 2.4, 11)\n```\n:::\n\n\n\n2. Replace the second element with `5.9`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_vec[2] <- 5.9\nex1_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2.0  5.9  2.4 11.0\n```\n:::\n:::\n\n\n\n3. Add the elements `3` and `1` to the beginning, and the elements \n`\"8.0\"` and `\"9.2\"` to the end of the vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nva_1 <- c(3, 1)\nva_2 <- c(\"8.0\", \"9.2\")\nex1_vec_extended <- c(va_1, ex1_vec, va_2)\nex1_vec_extended\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"3\"   \"1\"   \"2\"   \"5.9\" \"2.4\" \"11\"  \"8.0\" \"9.2\"\n```\n:::\n:::\n\n\n\n4. Create a vector with the numbers from -8 to 9 (step size: 0.5)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_vec_4 <- seq(-8, 9, by = 0.5)\nex1_vec_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 -5.0 -4.5 -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0\n[16] -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5\n[31]  7.0  7.5  8.0  8.5  9.0\n```\n:::\n:::\n\n\n\n5. Compute the square root of each element of the first vector \nusing vectorisation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(ex1_vec_4)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(ex1_vec_4): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [8]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[15]       NaN       NaN 0.0000000 0.7071068 1.0000000 1.2247449 1.4142136\n[22] 1.5811388 1.7320508 1.8708287 2.0000000 2.1213203 2.2360680 2.3452079\n[29] 2.4494897 2.5495098 2.6457513 2.7386128 2.8284271 2.9154759 3.0000000\n```\n:::\n:::\n\n\n\n6. Create a character vector containing then strings `\"Number_1\"` to \n`\"Number_5\"`. Use suitable helper functions to create this vector quickly.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_char_vec <- paste0(\"Number_\", seq(1, 5))\nex1_char_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number_1\" \"Number_2\" \"Number_3\" \"Number_4\" \"Number_5\"\n```\n:::\n:::\n\n\n\n\n# Exercise 2: Basic object types II\n\nConsider the following vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_2_vec <- c(1, \"2\", FALSE)\n```\n:::\n\n\n\n1. What is the type of this vector? Why?\n\n2. What happens if you coerce this vector into type integer? Why?\n\n3. What does `sum(is.na(x))` tell you about a vector `x`? What is happening here?\n\n4. Is it a good idea to use `as.integer()` on double characters to round them to \nthe next integer? Why (not)? What other ways are there to do the rounding?\n\n# Exercise 3: Define a function\n\nCreate functions that take a vector as input and returns:\n\n1. The last value.\n\n2. Every element except the last value and any missing values.\n\n3. Only even numbers.\n    \n> Hint: Use the operation `x %% y` to get the remainder from diving `x` by `y`, the so called 'modulo y'. For even numbers, the modulo 2 is zero.\n\nApply your function to the following example vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_3_vec <- c(1, -8, 99, 3, NA, 3, -0.5)\n```\n:::\n\n\n\n# Exercise 4: Lists\n\n1. Create a list that contains three elements called `'a'`, `'b'` and `'c'`.\nThe first element should correspond to a double vector with the elements\n`1.5`, `-2.9` and `99`.\nThe second element should correspond to a character vector with the elments\n`'Hello'`, `'3'`, and `'EUF'`.\nThe third element should contain three times the entry `FALSE`.\n\n2. Transform this list into a `data.frame` and a `tibble`. Then apply `str()` to\nget information about the respective structure. How do the results differ?\n\n\n# Exercise 5: Data frames and the study semester distribution at EUF\n\nThe package `DataScienceExercises` contains a data set called `EUFstudentsemesters`,\nwhich contains information about the distribution of study semesters of \nenrolled students at the EUF in 2021. You can shortcut the data set as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neuf_semesters <- DataScienceExercises::EUFstudentsemesters\n```\n:::\n\n\n\n1. What happens if you extract the column with study semesters as a vector\nand transform it into a `double`? \n\n2. What is the average study semester of those students being in their 8th or \nearlier semester?\n\n3. How many students are in their 9th or higher study semester?\n\n4. What does `typeof(euf_semesters)` return and why?\n",
    "supporting": [
      "session05-exercises_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}